
Necesito que me ayudes a redactar un documento que describe una entidad en un sistema de carreras de caballos implementada en solidity. Te voy a describir lo que hace (de forma bruta y desordenada) y tu debes estudiarlo y luego darme el texto bien estructurado de un documento que constará de una introducción y luego subtemas en donde se presentan los detalles de cada concepto presentado brevemente en la intro, sus definiciones y cómo han de implementarse. La descripción (bruta) es la siguiente:

# Entidad: MAnejador de Carreras
Esta entidad se encarga de manejar todo lo referente a carreras: inscripciones, resolución (de las carreras) y premios. En particular maneja varios conceptos:

Las Fixtures son grupos de carreras, próximas entre sí en el tiempo, que tienen una fecha de comienzo y que reciben inscripciones de los caballos hasta poco tiempo antes de arrancar la primer carrera, para reorganizar los caballos en varias carreas que terminarán por conformar la Fixture. La Fixture consta de una lista de carreras y cada carrera una lista de caballos. Este orden se define en base a los caballos inscriptios en la Fixture, definiendo cuantos caballos por careras y cuales caballos corren entre sí. Esto asegura una mejor distribución de los caballos en carreras para balanciar la cantidad de carreras y caballos en las mismas mientras que se mantienen competitivas (agrupa los caballos con un nivel parecido para que no haya victorias aseguradas de antemano).

Los caballos cuentan con una serie de propiedades que definen su performance durante una carrera. El manejador simula una carrera iterando una cantidad fija de veces discretizando el tiempo en TOTAL_RACE_ITERATIONS partes. En cada iteración (que representa una cantidad fija de segundos) se toma una semilla de un pool de semillas disponibes y se simula el avance de cada caballo (correspondiente a ese tramo de tiempo). Al cabo de las TOTAL_RACE_ITERATIONS iteraciones, cada caballo habrá acumulado un número diferente de avance lo que determina el resultado de la carrera (posiciones de los caballos). 

El pool de semillas es una cola de números pseudo-aleatorios que se van recibiendo en paralelo durante todo el tiempo, manteniendo en memoria sólamente los últimos MAX_SEED_QUEUE_LENGTH valores. Estos valores siempre estarán en memoria y serán reutilizados en cada resolución de las carreras. El factor clave es que este pool de semillas está constántemente cambiando y por tanto modificando el output de las carreras con cada nuevo valor. Para entender mejor, en este momento tenemos una lista concreta de seeds en el pool y si simulamos una carrera ahora tendrá un resultado, pero si ingresamos un nuevo seed al pool, el resultado de la misma simulación se espera que sea diferente.

Las carreras pueden ser simulladas en cualquier momento con una función sólo de lectura que toma el último seed para empezar la iteracción y a partir de ese seed, calcular el índice del seed a usar en la siguiente iteración. Por lo tanto, si entra un nuevo seed al pool, este será el utilizado para ararncar la iteraccion y los siguientes índices cambiarán completamente modificando radicalmente el output. Internamente se utilizará otra función de sólo lectura que toma un índice inicial y toma ese seed para la primera iteracción. Esto permite simular la misma carrera pero eligiendo cual seed usar como inicial y así obtener todos los resultados posibles para el conjunto de seeds que existe en cada momento en el pool de seeds, lo cual servirá para sacar una estadística previa a la carrera que ayude a determinar los caballos favoritos para cada carrera.

Cada carrera tiene 3 etapas:
E1: Antes de comenzar (race.start < block.timestamp). En esta etapa sólo se puede simular la carrea (no hay avance recordado) y se pueden usar cualquiera de los seeds como el inicial (pasando un índice cómo parámetro).
E2: La carrera está en curso (race.start > block.timestamp && race.start < block.timestamp + race.duration). Sólo se puede reproducir lo vivido hasta el momento (lo cual es inmutable) y simular el resto de la carrera (que varía con cada nuevo seed). Cada nuevo seed además de ser registrado, ejecuta una función que se llama runRace, la cual calcula cuanto tiempo ha pasado y cuantas iteraciones corresponden a ese tiemop pasado. Luego registra en una lista ordenada los seeds que fueron utilizados para cada tick pasado y que no haya sido registrado aun. Es decir, sólo registra los que faltan registrar y pertenecen al pasado. Al final de la simulación, escribe el resultado de la carrera. Este resultado se sobreescribirá con llamada a runRace.
E3: Ha terminado la carrera (race.start > block.timestamp + race.duration). En esta etapa ya no puede correrse la función runRace por lo tanto no hay más cambios y el resutado de la carrera es el que fue escrito en memoria la última vez que el algoritmo fue ejecutado. En esta etapa los caballos pordrán ser retirados de la carrera llevándose consigo el premio que corresponda, mientras que los apostadores que ganaron ya pueden retirar sus ganancias.

Para ilustrar mejor lo explicado anteriormente pongamos un ejemplo muy simplificado:
En la siguiente carrera tenemos dos caballos que compiten (A y B). Antes de empezar la carrera ya contamos con un pool lleno de seeds y si ejecutamos una simulación ocurre que 60% de las veces gana el caballo A y el otro 40% el caballo B. Con cada nuevo seed recibido, el pool cambia y con él, cambian los outputs de las diferentes simulaciones de la misma carrera. Pasado el instante de comienzo, ya no se podrá simular la carrera con cualquier índice. Sólo se podrá correr la carrera lo cual utiliza el prmier índice de la cola para arrancar las interaciones, lo cual determina un sólo resultado para la carrera. Supongamos que esta primera corrida de la carrera se da a apenas pocos segundos de haberse iniciado. Esto significaría que, de las 20 iteraciones que se van a hacer en total, quizás una de ellas haya que mantenerla fija porque corresponde a un tiempo que ya pasó y no debe ser modificado nunca más. Es así como se empieza a generar una lista de semillas elegidas de las disponibles que serán utilizadas para reproducir la carrera y que no tenga cambios en el futuro. Ahora supongamos que recibimos otra semilla, pero que esta cae más o menos a la mitad de la carrera. En ese caso, el primer índice que se va a tomar no va a ser del último semilla que ha llegado, sino que será tomado de la lista de índices recordados. Es decir, la primer semilla va a ser sacada de la lista que recuerda las semillas procesadas. Como solamente existe una, a partir de ahí, los índices de las nuevas semillas se van a calcular a partir de la semilla usada. Estas nuevas semillas, seleccionadas para los siguientes índices, serán guardadas en la lista de semillas para ser recordadas y reproducirse siempre de la misma manera.

Agregar Semillas  
El sistema de carreras utiliza una cola de semillas con una capacidad máxima de `MAX_SEED_POOL_SIZE`. Estas semillas alimentan el algoritmo de pseudoaleatoriedad encargado de resolver las carreras, donde hay dinero en juego, por lo que resulta fundamental evitar que una sola persona pueda controlar por completo su contenido. Si alguien lograra introducir todas las semillas del pool, podría predecir o manipular los resultados, afectando la integridad del sistema. Para prevenir esto, el algoritmo de incorporación de nuevas semillas impone dos mecanismos de protección: primero, las semillas se encadenan entre sí, de modo que cada nueva semilla depende de las anteriores, lo que garantiza que incluso un conjunto completo de semillas recientes esté influenciado por el historial previo; y segundo, las semillas no son proporcionadas directamente por los usuarios, sino que el sistema les entrega la última semilla disponible, la cual deben combinar con un valor aleatorio para generar un hash que cumpla con la condición de ser menor a `SEED_HASH_THRESHOLD`. Esto introduce una pequeña exigencia computacional del lado del cliente, haciendo inviable la carga masiva de semillas precalculadas con la intención de manipular el resultado de la carrera.


Fixtures
- reciben inscripciones de caballos todo el tiempo. Un caballo que se inscribe queda trancado hasta que lo asignan a una carrera competitiva (con caballos con niveles similares).
- Las Fixtures se rearman con cada caballo inscripto pero quedan fijas un tiempo RACE_ROUND_CONFIRM_TIME antes de la carrera. A paritr de ese momento las inscripciones de caballos serán tomadas en cuenta para la siguiente Fixture.
- el criterio para armar una Fixture es que las carreras no queden desbalanceadas. En todo momento habrá una lista ordenada por nivel de caballos inscriptos, los cuales serán tomados de abajo hacia arriba para formar carreras en donde no hayan más de MAX_HORSES_PER_RACE y los caballos no disten entre sí más de MAX_POINTS_DIFFERENCE_TOLERANCE de puntos totales ganados en previas carreras.

Costos y Premios en HAY
- Cada caballo debe pagar su inscripción con el token HAY, un monto que depende de su nivel. A mayor nivel, más paga. Costo de inscripción = RACE_HORSE_INSCRIPTION_COST_PER_LEVEL * horse.level()
- Al formarse una carrera con un mínimo de MIN_HORSES_PER_RACE y másximo de MAX_HORSES_PER_RACE, el nivel de la carrera será el nivel del caballo que tenga nivel más alto. El monto total en premios para las posiciones aumentará cuanto más alto sea los puntosnque tenga el caballo, en una proporción intermedia entre lineal y logarítmica. Es decir total_price = RACE_TOTAL_PRICE_BASE * better_horse.total_points / better_horse.level
- Premio por ganar. Cada carrera paga un total de HAY menor a total_price donde cada caballo que obtiene la posición P termina ganando total_price / (2^P). Es decir, el primero se lleva total_price/2, el segundo se lleva total_price/4, el tercero total_price/8 y así sicesivamente. Sobrando un total_price/(2^N) que no se paga. Es decir, el premio que se paga suma un total de total_price - total_price/(2^N) siendo N la cantidad de caballos que corren.
- Premio por correr. Cuando N caballos corren una carrera, se calcula cuanto es el total de tokens HAY que se recaudó por concepto de inscripción. Luego se calcula el promedio sumando todo eso y dividiendo por N. Cada caballo entonces cobrará su premio por la posición que obtenga en la carrera más un premio consuelo que es ese promedio. Esto generará que los peores caballos (dentro de una carrera) tiendan a cobrar más de lo que gastaron en inscribirse porque los caballoss que le ganaron son mejores y pagaron más. Sin embargo, si un buen caballo (que paga relativamente más) termina en último lugar, terminará cobrando menos de lo que pagó para inscribirse pues el premio consuelo (que es un promedio) es menor a lo que pagó.
- puede ocurrir que si un caballo es demasiado bueno y no tiene competidores, no será elegino para formar parte de la Fixture actual y por tanto no correrá ni podrá ser retirado. Quedará inscripto hasta que se le asigne una carrera en futuras Fixtures. Por cada Fixture que un caballo quede fuera de la selección y se lo posponga para otra Fixture, se le pagará un premio consuelo equivalente a el costo de inscripción * HORSE_NOT_CHOSEN_CONSOLATION_PRICE_MULTIPLIER unidades del token HAY. Es decir, será proportional al coste de inscripción. es una manera de poner en staking a tu caballo canador.

Premios en TLOS
existe un contrato aparte que recibe las apuestas de los apostadores sobre caballos en una carrera. Cada carrera entonces recibirá por concepto de apuestas un total de total_bets de tokens TLOS que se repartiran entre los ganadores. Todo lo recaudado que no tenga un ganador, será lo que se use para premios. De esa cantidad extraeremos un porcentaje para poremiar los dos primeros puestos. 

-- Fatla --
- logitud de las carreras y su duración en tiempo
- la lista de caballos inscriptos es independiente de las Fixtures
- simulación de carrear el indice sale del seed actual
