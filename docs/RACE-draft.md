
Necesito que me ayudes a redactar un documento que describe una entidad en un sistema de carreras de caballos implementada en solidity. Te voy a describir lo que hace (de forma bruta y desordenada) y tu debes estudiarlo y luego darme el texto de un documento que constará de una introducción y luego subtemas en donde se presentan conceptos, sus definiciones y cómo han de implementarse. La descripción (bruta) es la siguiente:

# Entidad: MAnejador de Carreras
Esta entidad se encarga de manejar todo lo referente a carreras: inscripciones, resolución (de las carreras) y premios. En particular maneja varios conceptos:
Las Rondas son grupos de carreras, próximas entre sí en el tiempo, que tienen una fecha de comienzo y que reciben inscripciones de los caballos hasta poco tiempo antes de arrancar la primer carrera, para reorganizar los caballos en varias carreas que terminarán por conformar la ronda. La ronda consta de una lista de carreras y cada carrera una lista de caballos. Este orden se define en base a los caballos inscriptios en la ronda, definiendo cuantos caballos por careras y cuales caballos corren entre sí. Esto asegura una mejor distribución de los caballos en carreras para balanciar la cantidad de carreras y caballos en las mismas mientras que se mantienen competitivas (agrupa los caballos con un nivel parecido para que no haya victorias aseguradas de antemano).

Los caballos cuentan con una serie de propiedades que definen su performance durante una carrera. El manejador simula una carrera iterando una cantidad fija de veces discretizando el tiempo en TOTAL_RACE_ITERATIONS partes. En cada iteración (que representa una cantidad fija de segundos) se toma una semilla de un pool de semillas disponibes y se simula el avance de cada caballo (correspondiente a ese tramo de tiempo). Al cabo de las TOTAL_RACE_ITERATIONS iteraciones, cada caballo habrá acumulado un número diferente de avance lo que determina el resultado de la carrera (posiciones de los caballos). 

El pool de semillas es una cola de números pseudo-aleatorios que se van recibiendo en paralelo durante todo el tiempo, manteniendo en memoria sólamente los últimos MAX_SEED_QUEUE_LENGTH valores. Estos valores siempre estarán en memoria y serán reutilizados en cada resolución de las carreras. El factor clave es que este pool de semillas está constántemente cambiando y por tanto modificando el output de las carreras con cada nuevo valor. Para entender mejor, en este momento tenemos una lista concreta de seeds en el pool y si simulamos una carrera ahora tendrá un resultado, pero si ingresamos un nuevo seed al pool, el resultado de la misma simulación se espera que sea diferente.

Las carreras pueden ser simulladas en cualquier momento con una función sólo de lectura que toma el último seed para empezar la iteracción y a partir de ese seed, calcular el índice del seed a usar en la siguiente iteración. Por lo tanto, si entra un nuevo seed al pool, este será el utilizado para ararncar la iteraccion y los siguientes índices cambiarán completamente modificando radicalmente el output. Internamente se utilizará otra función de sólo lectura que toma un índice inicial y toma ese seed para la primera iteracción. Esto permite simular la misma carrera pero eligiendo cual seed usar como inicial y así obtener todos los resultados posibles para el conjunto de seeds que existe en cada momento en el pool de seeds, lo cual servirá para sacar una estadística previa a la carrera que ayude a determinar los caballos favoritos para cada carrera.

Cada carrera tiene 3 etapas:
E1: Antes de comenzar (race.start < block.timestamp). En esta etapa sólo se puede simular la carrea (no hay avance recordado) y se pueden usar cualquiera de los seeds como el inicial (pasando un índice cómo parámetro).
E2: La carrera está en curso (race.start > block.timestamp && race.start < block.timestamp + race.duration). Sólo se puede reproducir lo vivido hasta el momento (lo cual es inmutable) y simular el resto de la carrera (que varía con cada nuevo seed). Cada nuevo seed además de ser registrado, ejecuta una función que se llama runRace, la cual calcula cuanto tiempo ha pasado y cuantas iteraciones corresponden a ese tiemop pasado. Luego registra en una lista ordenada los seeds que fueron utilizados para cada tick pasado y que no haya sido registrado aun. Es decir, sólo registra los que faltan registrar y pertenecen al pasado. Al final de la simulación, escribe el resultado de la carrera. Este resultado se sobreescribirá con llamada a runRace.
E3: Ha terminado la carrera (race.start > block.timestamp + race.duration). En esta etapa ya no puede correrse la función runRace por lo tanto no hay más cambios y el resutado de la carrera es el que fue escrito en memoria la última vez que el algoritmo fue ejecutado. En esta etapa los caballos pordrán ser retirados de la carrera llevándose consigo el premio que corresponda, mientras que los apostadores que ganaron ya pueden retirar sus ganancias.

Para ilustrar mejor lo explicado anteriormente pongamos un ejemplo muy simplificado:
En la siguiente carrera tenemos dos caballos que compiten (A y B). Antes de empezar la carrera ya contamos con un pool lleno de seeds y si ejecutamos una simulación ocurre que 60% de las veces gana el caballo A y el otro 40% el caballo B. Con cada nuevo seed recibido, el pool cambia y con él, cambian los outputs de las diferentes simulaciones de la misma carrera. Pasado el instante de comienzo, ya no se podrá simular la carrera con cualquier índice. Sólo se podrá correr la carrera lo cual utiliza el prmier índice de la cola para arrancar las interaciones, lo cual determina un sólo resultado para la carrera. Si durante la carrera no se recibe ningún

